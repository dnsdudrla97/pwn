ELF(5)                               Linux Programmer's Manual                               ELF(5)

NNAAMMEE
       elf - format of Executable and Linking Format (ELF) files

SSYYNNOOPPSSIISS
       ##iinncclluuddee <<eellff..hh>>

DDEESSCCRRIIPPTTIIOONN
       The  header  file  _<_e_l_f_._h_> defines the format of ELF executable binary files.  Amongst these
       files are normal executable files, relocatable object files, core files, and shared objects.

       An executable file using the ELF file format consists of an ELF header, followed by  a  pro-
       gram  header  table  or a section header table, or both.  The ELF header is always at offset
       zero of the file.  The program header table and the section header  table's  offset  in  the
       file are defined in the ELF header.  The two tables describe the rest of the particularities
       of the file.

       This header file describes the above mentioned headers as C  structures  and  also  includes
       structures for dynamic sections, relocation sections and symbol tables.

       The  following  types  are  used  for N-bit architectures (N=32,64, _E_l_f_N stands for _E_l_f_3_2 or
       _E_l_f_6_4, _u_i_n_t_N___t stands for _u_i_n_t_3_2___t or _u_i_n_t_6_4___t):

           ElfN_Addr       Unsigned program address, uintN_t
           ElfN_Off        Unsigned file offset, uintN_t
           ElfN_Section    Unsigned section index, uint16_t
           ElfN_Versym     Unsigned version symbol information, uint16_t
           Elf_Byte        unsigned char
           ElfN_Half       uint16_t
           ElfN_Sword      int32_t
           ElfN_Word       uint32_t
           ElfN_Sxword     int64_t
           ElfN_Xword      uint64_t

       (Note: The *BSD terminology is a bit different.  There  _E_l_f_6_4___H_a_l_f  is  twice  as  large  as
       _E_l_f_3_2___H_a_l_f,  and _E_l_f_6_4_Q_u_a_r_t_e_r is used for _u_i_n_t_1_6___t.  In order to avoid confusion these types
       are replaced by explicit ones in the below.)

       All data structures that the file format defines follow the  "natural"  size  and  alignment
       guidelines  for  the relevant class.  If necessary, data structures contain explicit padding
       to ensure 4-byte alignment for 4-byte objects, to force structure sizes to a multiple of  4,
       and so on.

       The ELF header is described by the type _E_l_f_3_2___E_h_d_r or _E_l_f_6_4___E_h_d_r:

           #define EI_NIDENT 16

           typedef struct {
               unsigned char e_ident[EI_NIDENT];
               uint16_t      e_type;
               uint16_t      e_machine;
               uint32_t      e_version;
               ElfN_Addr     e_entry;
               ElfN_Off      e_phoff;
               ElfN_Off      e_shoff;
               uint32_t      e_flags;
               uint16_t      e_ehsize;
               uint16_t      e_phentsize;
               uint16_t      e_phnum;
               uint16_t      e_shentsize;
               uint16_t      e_shnum;
               uint16_t      e_shstrndx;
           } ElfN_Ehdr;

       The fields have the following meanings:

       _e___i_d_e_n_t     This array of bytes specifies how to interpret the file, independent of the pro-
                   cessor or the file's remaining contents.  Within this array everything is  named
                   by  macros,  which  start with the prefix EEII__ and may contain values which start
                   with the prefix EELLFF.  The following macros are defined:

                   EEII__MMAAGG00     The first byte of the magic number.  It must be filled with EELLFFMMAAGG00.
                               (0: 0x7f)

                   EEII__MMAAGG11     The  second  byte  of the magic number.  It must be filled with EELLFF--
                               MMAAGG11.  (1: 'E')

                   EEII__MMAAGG22     The third byte of the magic number.  It must be filled with EELLFFMMAAGG22.
                               (2: 'L')

                   EEII__MMAAGG33     The  fourth  byte  of the magic number.  It must be filled with EELLFF--
                               MMAAGG33.  (3: 'F')

                   EEII__CCLLAASSSS    The fifth byte identifies the architecture for this binary:

                               EELLFFCCLLAASSSSNNOONNEE  This class is invalid.
                               EELLFFCCLLAASSSS3322    This defines the  32-bit  architecture.   It  supports
                                             machines with files and virtual address spaces up to 4
                                             Gigabytes.
                               EELLFFCCLLAASSSS6644    This defines the 64-bit architecture.

                   EEII__DDAATTAA     The sixth byte specifies the data encoding of the processor-specific
                               data in the file.  Currently these encodings are supported:

                               EELLFFDDAATTAANNOONNEE   Unknown data format.
                               EELLFFDDAATTAA22LLSSBB   Two's complement, little-endian.
                               EELLFFDDAATTAA22MMSSBB   Two's complement, big-endian.

                   EEII__VVEERRSSIIOONN  The seventh byte is the version number of the ELF specification:
                               EEVV__NNOONNEE       Invalid version.
                               EEVV__CCUURRRREENNTT    Current version.

                   EEII__OOSSAABBII    The eighth byte identifies the operating system and ABI to which the
                               object is targeted.  Some fields in other ELF structures have  flags
                               and  values that have platform-specific meanings; the interpretation
                               of those fields is determined by the value of this byte.  For  exam-
                               ple:

                               EELLFFOOSSAABBII__NNOONNEE       Same as ELFOSABI_SYSV
                               EELLFFOOSSAABBII__SSYYSSVV       UNIX System V ABI.
                               EELLFFOOSSAABBII__HHPPUUXX       HP-UX ABI.
                               EELLFFOOSSAABBII__NNEETTBBSSDD     NetBSD ABI.
                               EELLFFOOSSAABBII__LLIINNUUXX      Linux ABI.
                               EELLFFOOSSAABBII__SSOOLLAARRIISS    Solaris ABI.
                               EELLFFOOSSAABBII__IIRRIIXX       IRIX ABI.
                               EELLFFOOSSAABBII__FFRREEEEBBSSDD    FreeBSD ABI.
                               EELLFFOOSSAABBII__TTRRUU6644      TRU64 UNIX ABI.
                               EELLFFOOSSAABBII__AARRMM        ARM architecture ABI.
                               EELLFFOOSSAABBII__SSTTAANNDDAALLOONNEE Stand-alone (embedded) ABI.

                   EEII__AABBIIVVEERRSSIIOONN
                               The ninth byte identifies the version of the ABI to which the object
                               is targeted.  This field is used to distinguish  among  incompatible
                               versions  of  an  ABI.  The interpretation of this version number is
                               dependent on the ABI identified by the EEII__OOSSAABBII field.  Applications
                               conforming to this specification use the value 0.

                   EEII__PPAADD      Start  of  padding.  These bytes are reserved and set to zero.  Pro-
                               grams which read them should ignore them.  The value for EEII__PPAADD will
                               change in the future if currently unused bytes are given meanings.

                   EEII__NNIIDDEENNTT   The size of the _e___i_d_e_n_t array.

       _e___t_y_p_e      This member of the structure identifies the object file type:

                   EETT__NNOONNEE     An unknown type.
                   EETT__RREELL      A relocatable file.
                   EETT__EEXXEECC     An executable file.
                   EETT__DDYYNN      A shared object.
                   EETT__CCOORREE     A core file.

       _e___m_a_c_h_i_n_e   This  member  specifies  the  required architecture for an individual file.  For
                   example:

                   EEMM__NNOONNEE     An unknown machine.
                   EEMM__MM3322      AT&T WE 32100.
                   EEMM__SSPPAARRCC    Sun Microsystems SPARC.
                   EEMM__338866      Intel 80386.
                   EEMM__6688KK      Motorola 68000.
                   EEMM__8888KK      Motorola 88000.
                   EEMM__886600      Intel 80860.
                   EEMM__MMIIPPSS     MIPS RS3000 (big-endian only).
                   EEMM__PPAARRIISSCC   HP/PA.
                   EEMM__SSPPAARRCC3322PPLLUUSS
                               SPARC with enhanced instruction set.
                   EEMM__PPPPCC      PowerPC.
                   EEMM__PPPPCC6644    PowerPC 64-bit.
                   EEMM__SS339900     IBM S/390
                   EEMM__AARRMM      Advanced RISC Machines
                   EEMM__SSHH       Renesas SuperH
                   EEMM__SSPPAARRCCVV99  SPARC v9 64-bit.
                   EEMM__IIAA__6644    Intel Itanium
                   EEMM__XX8866__6644   AMD x86-64
                   EEMM__VVAAXX      DEC Vax.

       _e___v_e_r_s_i_o_n   This member identifies the file version:

                   EEVV__NNOONNEE     Invalid version.
                   EEVV__CCUURRRREENNTT  Current version.

       _e___e_n_t_r_y     This member gives the virtual address to which the system first  transfers  con-
                   trol,  thus  starting  the  process.  If the file has no associated entry point,
                   this member holds zero.

       _e___p_h_o_f_f     This member holds the program header table's file offset in bytes.  If the  file
                   has no program header table, this member holds zero.

       _e___s_h_o_f_f     This  member holds the section header table's file offset in bytes.  If the file
                   has no section header table, this member holds zero.

       _e___f_l_a_g_s     This member holds processor-specific flags associated with the file.  Flag names
                   take the form EF_`machine_flag'.  Currently no flags have been defined.

       _e___e_h_s_i_z_e    This member holds the ELF header's size in bytes.

       _e___p_h_e_n_t_s_i_z_e This  member  holds  the size in bytes of one entry in the file's program header
                   table; all entries are the same size.

       _e___p_h_n_u_m     This member holds the number of entries in the program header table.   Thus  the
                   product  of  _e___p_h_e_n_t_s_i_z_e and _e___p_h_n_u_m gives the table's size in bytes.  If a file
                   has no program header, _e___p_h_n_u_m holds the value zero.

                   If the number of entries in the program header table is larger than or equal  to
                   PPNN__XXNNUUMM  (0xffff),  this  member  holds  PPNN__XXNNUUMM (0xffff) and the real number of
                   entries in the program header table is held in the _s_h___i_n_f_o member of the initial
                   entry  in  section  header  table.  Otherwise, the _s_h___i_n_f_o member of the initial
                   entry contains the value zero.

                   PPNN__XXNNUUMM  This is defined as 0xffff, the largest number _e___p_h_n_u_m can have,  speci-
                            fying where the actual number of program headers is assigned.

       _e___s_h_e_n_t_s_i_z_e This  member  holds  a sections header's size in bytes.  A section header is one
                   entry in the section header table; all entries are the same size.

       _e___s_h_n_u_m     This member holds the number of entries in the section header table.   Thus  the
                   product  of  _e___s_h_e_n_t_s_i_z_e  and  _e___s_h_n_u_m  gives the section header table's size in
                   bytes.  If a file has no section header table, _e___s_h_n_u_m holds the value of zero.

                   If the number of entries in the section header table is larger than or equal  to
                   SSHHNN__LLOORREESSEERRVVEE  (0xff00),  _e___s_h_n_u_m  holds  the  value zero and the real number of
                   entries in the section header table is held in the _s_h___s_i_z_e member of the initial
                   entry  in  section  header  table.  Otherwise, the _s_h___s_i_z_e member of the initial
                   entry in the section header table holds the value zero.

       _e___s_h_s_t_r_n_d_x  This member holds the section header table index of the  entry  associated  with
                   the  section  name  string table.  If the file has no section name string table,
                   this member holds the value SSHHNN__UUNNDDEEFF.

                   If the index of section name string table section is larger  than  or  equal  to
                   SSHHNN__LLOORREESSEERRVVEE (0xff00), this member holds SSHHNN__XXIINNDDEEXX (0xffff) and the real index
                   of the section name string table section is held in the _s_h___l_i_n_k  member  of  the
                   initial  entry  in  section  header table.  Otherwise, the _s_h___l_i_n_k member of the
                   initial entry in section header table contains the value zero.

                   SSHHNN__UUNNDDEEFF     This value marks an undefined, missing, irrelevant,  or  otherwise
                                 meaningless  section  reference.   For example, a symbol "defined"
                                 relative to section number SSHHNN__UUNNDDEEFF is an undefined symbol.

                   SSHHNN__LLOORREESSEERRVVEE This value specifies the lower bound  of  the  range  of  reserved
                                 indices.

                   SSHHNN__LLOOPPRROOCC    Values  greater  than or equal to SSHHNN__HHIIPPRROOCC are reserved for pro-
                                 cessor-specific semantics.

                   SSHHNN__HHIIPPRROOCC    Values less than or equal to SSHHNN__LLOOPPRROOCC are reserved  for  proces-
                                 sor-specific semantics.

                   SSHHNN__AABBSS       This  value specifies absolute values for the corresponding refer-
                                 ence.  For example, symbols defined  relative  to  section  number
                                 SSHHNN__AABBSS have absolute values and are not affected by relocation.

                   SSHHNN__CCOOMMMMOONN    Symbols  defined relative to this section are common symbols, such
                                 as Fortran COMMON or unallocated C external variables.

                   SSHHNN__HHIIRREESSEERRVVEE This value specifies the upper bound  of  the  range  of  reserved
                                 indices  between  SSHHNN__LLOORREESSEERRVVEE  and SSHHNN__HHIIRREESSEERRVVEE, inclusive; the
                                 values do not reference the section header table.   That  is,  the
                                 section  header  table  does  _n_o_t contain entries for the reserved
                                 indices.

       An executable or shared object file's program header table is an array of  structures,  each
       describing a segment or other information the system needs to prepare the program for execu-
       tion.  An object file _s_e_g_m_e_n_t contains one or more _s_e_c_t_i_o_n_s.  Program headers are meaningful
       only  for  executable and shared object files.  A file specifies its own program header size
       with the ELF header's _e___p_h_e_n_t_s_i_z_e and _e___p_h_n_u_m members.  The ELF program header is  described
       by the type _E_l_f_3_2___P_h_d_r or _E_l_f_6_4___P_h_d_r depending on the architecture:

           typedef struct {
               uint32_t   p_type;
               Elf32_Off  p_offset;
               Elf32_Addr p_vaddr;
               Elf32_Addr p_paddr;
               uint32_t   p_filesz;
               uint32_t   p_memsz;
               uint32_t   p_flags;
               uint32_t   p_align;
           } Elf32_Phdr;

           typedef struct {
               uint32_t   p_type;
               uint32_t   p_flags;
               Elf64_Off  p_offset;
               Elf64_Addr p_vaddr;
               Elf64_Addr p_paddr;
               uint64_t   p_filesz;
               uint64_t   p_memsz;
               uint64_t   p_align;
           } Elf64_Phdr;

       The main difference between the 32-bit and the 64-bit program header lies in the location of
       the _p___f_l_a_g_s member in the total struct.

       _p___t_y_p_e      This member of the Phdr struct tells what kind of  segment  this  array  element
                   describes or how to interpret the array element's information.

                   PPTT__NNUULLLL     The  array element is unused and the other members' values are unde-
                               fined.  This lets the program header have ignored entries.

                   PPTT__LLOOAADD     The  array  element  specifies  a  loadable  segment,  described  by
                               _p___f_i_l_e_s_z  and  _p___m_e_m_s_z.   The  bytes from the file are mapped to the
                               beginning of the memory  segment.   If  the  segment's  memory  size
                               _p___m_e_m_s_z is larger than the file size _p___f_i_l_e_s_z, the "extra" bytes are
                               defined to hold the value 0 and to follow the segment's  initialized
                               area.   The file size may not be larger than the memory size.  Load-
                               able segment entries in the program header table appear in ascending
                               order, sorted on the _p___v_a_d_d_r member.

                   PPTT__DDYYNNAAMMIICC  The array element specifies dynamic linking information.

                   PPTT__IINNTTEERRPP   The  array  element specifies the location and size of a null-termi-
                               nated pathname to invoke as an interpreter.  This  segment  type  is
                               meaningful only for executable files (though it may occur for shared
                               objects).  However it may not occur more than once in a file.  If it
                               is present, it must precede any loadable segment entry.

                   PPTT__NNOOTTEE     The  array  element  specifies  the  location and size for auxiliary
                               information.

                   PPTT__SSHHLLIIBB    This segment type is reserved but has unspecified  semantics.   Pro-
                               grams  that  contain an array element of this type do not conform to
                               the ABI.

                   PPTT__PPHHDDRR     The array element, if present, specifies the location  and  size  of
                               the  program header table itself, both in the file and in the memory
                               image of the program.  This segment type may  not  occur  more  than
                               once  in  a file.  Moreover, it may occur only if the program header
                               table is part of the memory image of the program.  If it is present,
                               it must precede any loadable segment entry.

                   PPTT__LLOOPPRROOCC   Values  greater  than or equal to PPTT__HHIIPPRROOCC are reserved for proces-
                               sor-specific semantics.

                   PPTT__HHIIPPRROOCC   Values less than or equal to PPTT__LLOOPPRROOCC are reserved  for  processor-
                               specific semantics.

                   PPTT__GGNNUU__SSTTAACCKK
                               GNU extension which is used by the Linux kernel to control the state
                               of the stack via the flags set in the _p___f_l_a_g_s member.

       _p___o_f_f_s_e_t    This member holds the offset from the beginning of the file at which  the  first
                   byte of the segment resides.

       _p___v_a_d_d_r     This  member  holds  the  virtual address at which the first byte of the segment
                   resides in memory.

       _p___p_a_d_d_r     On systems for which physical addressing is relevant, this  member  is  reserved
                   for  the segment's physical address.  Under BSD this member is not used and must
                   be zero.

       _p___f_i_l_e_s_z    This member holds the number of bytes in the file image of the segment.  It  may
                   be zero.

       _p___m_e_m_s_z     This  member  holds  the number of bytes in the memory image of the segment.  It
                   may be zero.

       _p___f_l_a_g_s     This member holds a bit mask of flags relevant to the segment:

                   PPFF__XX   An executable segment.
                   PPFF__WW   A writable segment.
                   PPFF__RR   A readable segment.

                   A text segment commonly has the flags PPFF__XX and PPFF__RR.  A  data  segment  commonly
                   has PPFF__XX, PPFF__WW and PPFF__RR.

       _p___a_l_i_g_n     This  member  holds the value to which the segments are aligned in memory and in
                   the file.  Loadable process segments must have congruent values for _p___v_a_d_d_r  and
                   _p___o_f_f_s_e_t,  modulo  the  page  size.  Values of zero and one mean no alignment is
                   required.  Otherwise, _p___a_l_i_g_n should be a positive, integral power of  two,  and
                   _p___v_a_d_d_r should equal _p___o_f_f_s_e_t, modulo _p___a_l_i_g_n.

       A  file's  section header table lets one locate all the file's sections.  The section header
       table is an array of _E_l_f_3_2___S_h_d_r or _E_l_f_6_4___S_h_d_r structures.  The ELF header's  _e___s_h_o_f_f  member
       gives  the  byte offset from the beginning of the file to the section header table.  _e___s_h_n_u_m
       holds the number of entries the section header table contains.  _e___s_h_e_n_t_s_i_z_e holds  the  size
       in bytes of each entry.

       A  section  header  table  index  is a subscript into this array.  Some section header table
       indices are reserved: the initial entry and the indices between SSHHNN__LLOORREESSEERRVVEE and  SSHHNN__HHIIRREE--
       SSEERRVVEE.   The  initial  entry is used in ELF extensions for _e___p_h_n_u_m, _e___s_h_n_u_m and _e___s_t_r_n_d_x; in
       other cases, each field in the initial entry is set to zero.  An object file does  not  have
       sections for these special indices:

              SSHHNN__UUNNDDEEFF     This  value marks an undefined, missing, irrelevant, or otherwise mean-
                            ingless section reference.

              SSHHNN__LLOORREESSEERRVVEE This value specifies the lower bound of the range of reserved indices.

              SSHHNN__LLOOPPRROOCC    Values greater than or equal to SSHHNN__HHIIPPRROOCC are reserved for  processor-
                            specific semantics.

              SSHHNN__HHIIPPRROOCC    Values less than or equal to SSHHNN__LLOOPPRROOCC are reserved for processor-spe-
                            cific semantics.

              SSHHNN__AABBSS       This value specifies the absolute value for  the  corresponding  refer-
                            ence.  For example, a symbol defined relative to section number SSHHNN__AABBSS
                            has an absolute value and is not affected by relocation.

              SSHHNN__CCOOMMMMOONN    Symbols defined relative to this section are common  symbols,  such  as
                            FORTRAN COMMON or unallocated C external variables.

              SSHHNN__HHIIRREESSEERRVVEE This  value specifies the upper bound of the range of reserved indices.
                            The system reserves indices between  SSHHNN__LLOORREESSEERRVVEE  and  SSHHNN__HHIIRREESSEERRVVEE,
                            inclusive.   The  section header table does not contain entries for the
                            reserved indices.

       The section header has the following structure:

           typedef struct {
               uint32_t   sh_name;
               uint32_t   sh_type;
               uint32_t   sh_flags;
               Elf32_Addr sh_addr;
               Elf32_Off  sh_offset;
               uint32_t   sh_size;
               uint32_t   sh_link;
               uint32_t   sh_info;
               uint32_t   sh_addralign;
               uint32_t   sh_entsize;
           } Elf32_Shdr;

           typedef struct {
               uint32_t   sh_name;
               uint32_t   sh_type;
               uint64_t   sh_flags;
               Elf64_Addr sh_addr;
               Elf64_Off  sh_offset;
               uint64_t   sh_size;
               uint32_t   sh_link;
               uint32_t   sh_info;
               uint64_t   sh_addralign;
               uint64_t   sh_entsize;
           } Elf64_Shdr;

       No real differences exist between the 32-bit and 64-bit section headers.

       _s_h___n_a_m_e   This member specifies the name of the section.  Its value is  an  index  into  the
                 section  header  string  table  section,  giving the location of a null-terminated
                 string.

       _s_h___t_y_p_e   This member categorizes the section's contents and semantics.

                 SSHHTT__NNUULLLL       This value marks the section header as inactive.  It does not  have
                                an  associated  section.   Other members of the section header have
                                undefined values.

                 SSHHTT__PPRROOGGBBIITTSS   This section holds information defined by the program, whose format
                                and meaning are determined solely by the program.

                 SSHHTT__SSYYMMTTAABB     This  section holds a symbol table.  Typically, SSHHTT__SSYYMMTTAABB provides
                                symbols for link editing, though it may also be  used  for  dynamic
                                linking.   As  a complete symbol table, it may contain many symbols
                                unnecessary for dynamic linking.  An object file can also contain a
                                SSHHTT__DDYYNNSSYYMM section.

                 SSHHTT__SSTTRRTTAABB     This  section holds a string table.  An object file may have multi-
                                ple string table sections.

                 SSHHTT__RREELLAA       This section holds relocation entries with explicit  addends,  such
                                as type _E_l_f_3_2___R_e_l_a for the 32-bit class of object files.  An object
                                may have multiple relocation sections.

                 SSHHTT__HHAASSHH       This section holds a symbol hash table.  An object participating in
                                dynamic  linking  must contain a symbol hash table.  An object file
                                may have only one hash table.

                 SSHHTT__DDYYNNAAMMIICC    This section holds information for dynamic linking.  An object file
                                may have only one dynamic section.

                 SSHHTT__NNOOTTEE       This section holds information that marks the file in some way.

                 SSHHTT__NNOOBBIITTSS     A  section of this type occupies no space in the file but otherwise
                                resembles SSHHTT__PPRROOGGBBIITTSS.  Although this section contains  no  bytes,
                                the _s_h___o_f_f_s_e_t member contains the conceptual file offset.

                 SSHHTT__RREELL        This  section  holds  relocation  offsets without explicit addends,
                                such as type _E_l_f_3_2___R_e_l for the 32-bit class of  object  files.   An
                                object file may have multiple relocation sections.

                 SSHHTT__SSHHLLIIBB      This section is reserved but has unspecified semantics.

                 SSHHTT__DDYYNNSSYYMM     This  section  holds  a minimal set of dynamic linking symbols.  An
                                object file can also contain a SSHHTT__SSYYMMTTAABB section.

                 SSHHTT__LLOOPPRROOCC     This value up to and including SSHHTT__HHIIPPRROOCC is reserved  for  proces-
                                sor-specific semantics.

                 SSHHTT__HHIIPPRROOCC     This value down to and including SSHHTT__LLOOPPRROOCC is reserved for proces-
                                sor-specific semantics.

                 SSHHTT__LLOOUUSSEERR     This value specifies the  lower  bound  of  the  range  of  indices
                                reserved for application programs.

                 SSHHTT__HHIIUUSSEERR     This  value  specifies  the  upper  bound  of  the range of indices
                                reserved  for  application   programs.    Section   types   between
                                SSHHTT__LLOOUUSSEERR  and  SSHHTT__HHIIUUSSEERR may be used by the application, without
                                conflicting with current or future system-defined section types.

       _s_h___f_l_a_g_s  Sections support one-bit flags that describe miscellaneous attributes.  If a  flag
                 bit  is  set  in  _s_h___f_l_a_g_s, the attribute is "on" for the section.  Otherwise, the
                 attribute is "off" or does not apply.  Undefined attributes are set to zero.

                 SSHHFF__WWRRIITTEE      This section contains data that should be writable  during  process
                                execution.

                 SSHHFF__AALLLLOOCC      This  section  occupies memory during process execution.  Some con-
                                trol sections do not reside in the memory image of an object  file.
                                This attribute is off for those sections.

                 SSHHFF__EEXXEECCIINNSSTTRR  This section contains executable machine instructions.

                 SSHHFF__MMAASSKKPPRROOCC   All  bits included in this mask are reserved for processor-specific
                                semantics.

       _s_h___a_d_d_r   If this section appears in the memory image of a process, this  member  holds  the
                 address  at  which  the section's first byte should reside.  Otherwise, the member
                 contains zero.

       _s_h___o_f_f_s_e_t This member's value holds the byte offset from the beginning of the  file  to  the
                 first byte in the section.  One section type, SSHHTT__NNOOBBIITTSS, occupies no space in the
                 file, and its _s_h___o_f_f_s_e_t member locates the conceptual placement in the file.

       _s_h___s_i_z_e   This member holds the section's  size  in  bytes.   Unless  the  section  type  is
                 SSHHTT__NNOOBBIITTSS,  the  section  occupies  _s_h___s_i_z_e bytes in the file.  A section of type
                 SSHHTT__NNOOBBIITTSS may have a nonzero size, but it occupies no space in the file.

       _s_h___l_i_n_k   This member holds a section header table index link, whose interpretation  depends
                 on the section type.

       _s_h___i_n_f_o   This  member  holds extra information, whose interpretation depends on the section
                 type.

       _s_h___a_d_d_r_a_l_i_g_n
                 Some sections have address alignment constraints.  If a section  holds  a  double-
                 word,  the  system  must ensure doubleword alignment for the entire section.  That
                 is, the value  of  _s_h___a_d_d_r  must  be  congruent  to  zero,  modulo  the  value  of
                 _s_h___a_d_d_r_a_l_i_g_n.   Only zero and positive integral powers of two are allowed.  Values
                 of zero or one mean the section has no alignment constraints.

       _s_h___e_n_t_s_i_z_e
                 Some sections hold a table of fixed-sized entries, such as a  symbol  table.   For
                 such  a  section, this member gives the size in bytes for each entry.  This member
                 contains zero if the section does not hold a table of fixed-size entries.

       Various sections hold program and control information:

       _._b_s_s      This section holds uninitialized data that contributes  to  the  program's  memory
                 image.  By definition, the system initializes the data with zeros when the program
                 begins to run.  This section is of  type  SSHHTT__NNOOBBIITTSS.   The  attribute  types  are
                 SSHHFF__AALLLLOOCC and SSHHFF__WWRRIITTEE.

       _._c_o_m_m_e_n_t  This section holds version control information.  This section is of type SSHHTT__PPRROOGG--
                 BBIITTSS.  No attribute types are used.

       _._c_t_o_r_s    This section holds initialized pointers to the C++  constructor  functions.   This
                 section is of type SSHHTT__PPRROOGGBBIITTSS.  The attribute types are SSHHFF__AALLLLOOCC and SSHHFF__WWRRIITTEE.

       _._d_a_t_a     This section holds initialized data that contribute to the program's memory image.
                 This section is of type SSHHTT__PPRROOGGBBIITTSS.   The  attribute  types  are  SSHHFF__AALLLLOOCC  and
                 SSHHFF__WWRRIITTEE.

       _._d_a_t_a_1    This section holds initialized data that contribute to the program's memory image.
                 This section is of type SSHHTT__PPRROOGGBBIITTSS.   The  attribute  types  are  SSHHFF__AALLLLOOCC  and
                 SSHHFF__WWRRIITTEE.

       _._d_e_b_u_g    This  section holds information for symbolic debugging.  The contents are unspeci-
                 fied.  This section is of type SSHHTT__PPRROOGGBBIITTSS.  No attribute types are used.

       _._d_t_o_r_s    This section holds initialized pointers to the  C++  destructor  functions.   This
                 section is of type SSHHTT__PPRROOGGBBIITTSS.  The attribute types are SSHHFF__AALLLLOOCC and SSHHFF__WWRRIITTEE.

       _._d_y_n_a_m_i_c  This  section  holds  dynamic  linking information.  The section's attributes will
                 include the SSHHFF__AALLLLOOCC bit.  Whether the SSHHFF__WWRRIITTEE bit  is  set  is  processor-spe-
                 cific.  This section is of type SSHHTT__DDYYNNAAMMIICC.  See the attributes above.

       _._d_y_n_s_t_r   This  section  holds strings needed for dynamic linking, most commonly the strings
                 that represent the names associated with symbol table entries.  This section is of
                 type SSHHTT__SSTTRRTTAABB.  The attribute type used is SSHHFF__AALLLLOOCC.

       _._d_y_n_s_y_m   This  section  holds  the  dynamic  linking symbol table.  This section is of type
                 SSHHTT__DDYYNNSSYYMM.  The attribute used is SSHHFF__AALLLLOOCC.

       _._f_i_n_i     This section holds executable instructions that contribute to the process termina-
                 tion  code.  When a program exits normally the system arranges to execute the code
                 in this section.  This section is of type SSHHTT__PPRROOGGBBIITTSS.  The attributes  used  are
                 SSHHFF__AALLLLOOCC and SSHHFF__EEXXEECCIINNSSTTRR.

       _._g_n_u_._v_e_r_s_i_o_n
                 This section holds the version symbol table, an array of _E_l_f_N___H_a_l_f elements.  This
                 section is of type SSHHTT__GGNNUU__vveerrssyymm.  The attribute type used is SSHHFF__AALLLLOOCC.

       _._g_n_u_._v_e_r_s_i_o_n___d
                 This section holds the version symbol definitions, a table of  _E_l_f_N___V_e_r_d_e_f  struc-
                 tures.   This  section  is  of  type  SSHHTT__GGNNUU__vveerrddeeff.   The attribute type used is
                 SSHHFF__AALLLLOOCC.

       _._g_n_u_._v_e_r_s_i_o_n___r
                 This section holds the version symbol needed elements,  a  table  of  _E_l_f_N___V_e_r_n_e_e_d
                 structures.   This  section is of type SSHHTT__GGNNUU__vveerrssyymm.  The attribute type used is
                 SSHHFF__AALLLLOOCC.

       _._g_o_t      This section holds the global offset table.  This section is of type SSHHTT__PPRROOGGBBIITTSS.
                 The attributes are processor-specific.

       _._h_a_s_h     This  section  holds  a symbol hash table.  This section is of type SSHHTT__HHAASSHH.  The
                 attribute used is SSHHFF__AALLLLOOCC.

       _._i_n_i_t     This section holds executable instructions that contribute to the process initial-
                 ization  code.   When  a  program starts to run the system arranges to execute the
                 code in this section before calling the main program entry point.  This section is
                 of type SSHHTT__PPRROOGGBBIITTSS.  The attributes used are SSHHFF__AALLLLOOCC and SSHHFF__EEXXEECCIINNSSTTRR.

       _._i_n_t_e_r_p   This section holds the pathname of a program interpreter.  If the file has a load-
                 able segment that includes the section, the section's attributes will include  the
                 SSHHFF__AALLLLOOCC  bit.   Otherwise,  that  bit  will  be  off.   This  section is of type
                 SSHHTT__PPRROOGGBBIITTSS.

       _._l_i_n_e     This section holds line number information for symbolic debugging, which describes
                 the  correspondence between the program source and the machine code.  The contents
                 are unspecified.  This section is of type SSHHTT__PPRROOGGBBIITTSS.  No  attribute  types  are
                 used.

       _._n_o_t_e     This  section  holds information in the "Note Section" format.  This section is of
                 type SSHHTT__NNOOTTEE.  No attribute types are used.  OpenBSD native  executables  usually
                 contain  a  _._n_o_t_e_._o_p_e_n_b_s_d_._i_d_e_n_t  section to identify themselves, for the kernel to
                 bypass any compatibility ELF binary emulation tests when loading the file.

       _._n_o_t_e_._G_N_U_-_s_t_a_c_k
                 This section is used in Linux object files for declaring stack  attributes.   This
                 section  is of type SSHHTT__PPRROOGGBBIITTSS.  The only attribute used is SSHHFF__EEXXEECCIINNSSTTRR.  This
                 indicates to the GNU linker that the object file requires an executable stack.

       _._p_l_t      This section holds the procedure linkage table.  This section is of type SSHHTT__PPRROOGG--
                 BBIITTSS.  The attributes are processor-specific.

       _._r_e_l_N_A_M_E  This  section  holds relocation information as described below.  If the file has a
                 loadable segment that includes relocation, the section's attributes  will  include
                 the SSHHFF__AALLLLOOCC bit.  Otherwise, the bit will be off.  By convention, "NAME" is sup-
                 plied by the section to which the relocations apply.  Thus  a  relocation  section
                 for  ..tteexxtt  normally  would  have  the  name  ..rreell..tteexxtt.   This section is of type
                 SSHHTT__RREELL.

       _._r_e_l_a_N_A_M_E This section holds relocation information as described below.  If the file  has  a
                 loadable  segment  that includes relocation, the section's attributes will include
                 the SSHHFF__AALLLLOOCC bit.  Otherwise, the bit will be off.  By convention, "NAME" is sup-
                 plied  by  the  section to which the relocations apply.  Thus a relocation section
                 for ..tteexxtt normally would have the  name  ..rreellaa..tteexxtt.   This  section  is  of  type
                 SSHHTT__RREELLAA.

       _._r_o_d_a_t_a   This section holds read-only data that typically contributes to a nonwritable seg-
                 ment in the process image.  This section is of type SSHHTT__PPRROOGGBBIITTSS.   The  attribute
                 used is SSHHFF__AALLLLOOCC.

       _._r_o_d_a_t_a_1  This section holds read-only data that typically contributes to a nonwritable seg-
                 ment in the process image.  This section is of type SSHHTT__PPRROOGGBBIITTSS.   The  attribute
                 used is SSHHFF__AALLLLOOCC.

       _._s_h_s_t_r_t_a_b This  section  holds  section  names.   This  section  is  of type SSHHTT__SSTTRRTTAABB.  No
                 attribute types are used.

       _._s_t_r_t_a_b   This section holds strings, most commonly the strings  that  represent  the  names
                 associated  with  symbol  table  entries.  If the file has a loadable segment that
                 includes the symbol string  table,  the  section's  attributes  will  include  the
                 SSHHFF__AALLLLOOCC  bit.   Otherwise,  the  bit  will  be  off.   This  section  is of type
                 SSHHTT__SSTTRRTTAABB.

       _._s_y_m_t_a_b   This section holds a symbol table.  If  the  file  has  a  loadable  segment  that
                 includes  the  symbol  table,  the section's attributes will include the SSHHFF__AALLLLOOCC
                 bit.  Otherwise, the bit will be off.  This section is of type SSHHTT__SSYYMMTTAABB.

       _._t_e_x_t     This section holds the "text", or executable instructions,  of  a  program.   This
                 section   is  of  type  SSHHTT__PPRROOGGBBIITTSS.   The  attributes  used  are  SSHHFF__AALLLLOOCC  and
                 SSHHFF__EEXXEECCIINNSSTTRR.

       String table sections hold null-terminated character  sequences,  commonly  called  strings.
       The  object file uses these strings to represent symbol and section names.  One references a
       string as an index into the string table section.  The first byte, which is index  zero,  is
       defined  to  hold  a  null byte ('\0').  Similarly, a string table's last byte is defined to
       hold a null byte, ensuring null termination for all strings.

       An object file's symbol table holds information needed to locate and  relocate  a  program's
       symbolic definitions and references.  A symbol table index is a subscript into this array.

           typedef struct {
               uint32_t      st_name;
               Elf32_Addr    st_value;
               uint32_t      st_size;
               unsigned char st_info;
               unsigned char st_other;
               uint16_t      st_shndx;
           } Elf32_Sym;

           typedef struct {
               uint32_t      st_name;
               unsigned char st_info;
               unsigned char st_other;
               uint16_t      st_shndx;
               Elf64_Addr    st_value;
               uint64_t      st_size;
           } Elf64_Sym;

       The 32-bit and 64-bit versions have the same members, just in a different order.

       _s_t___n_a_m_e   This member holds an index into the object file's symbol string table, which holds
                 character representations of the symbol names.  If the value is nonzero, it repre-
                 sents  a string table index that gives the symbol name.  Otherwise, the symbol ta-
                 ble has no name.

       _s_t___v_a_l_u_e  This member gives the value of the associated symbol.

       _s_t___s_i_z_e   Many symbols have associated sizes.  This member holds zero if the symbol  has  no
                 size or an unknown size.

       _s_t___i_n_f_o   This member specifies the symbol's type and binding attributes:

                 SSTTTT__NNOOTTYYPPEE  The symbol's type is not defined.

                 SSTTTT__OOBBJJEECCTT  The symbol is associated with a data object.

                 SSTTTT__FFUUNNCC    The symbol is associated with a function or other executable code.

                 SSTTTT__SSEECCTTIIOONN The symbol is associated with a section.  Symbol table entries of this
                             type exist primarily for relocation and normally have SSTTBB__LLOOCCAALL  bind-
                             ings.

                 SSTTTT__FFIILLEE    By  convention,  the  symbol's  name gives the name of the source file
                             associated with the object file.  A file symbol  has  SSTTBB__LLOOCCAALL  bind-
                             ings,  its  section  index  is  SSHHNN__AABBSS,  and  it  precedes  the other
                             SSTTBB__LLOOCCAALL symbols of the file, if it is present.

                 SSTTTT__LLOOPPRROOCC  This value up to and including SSTTTT__HHIIPPRROOCC is reserved  for  processor-
                             specific semantics.

                 SSTTTT__HHIIPPRROOCC  This value down to and including SSTTTT__LLOOPPRROOCC is reserved for processor-
                             specific semantics.

                 SSTTBB__LLOOCCAALL   Local symbols are not visible outside the object file containing their
                             definition.   Local  symbols  of  the  same name may exist in multiple
                             files without interfering with each other.

                 SSTTBB__GGLLOOBBAALL  Global symbols are visible to all object files  being  combined.   One
                             file's definition of a global symbol will satisfy another file's unde-
                             fined reference to the same symbol.

                 SSTTBB__WWEEAAKK    Weak symbols resemble global symbols, but their definitions have lower
                             precedence.

                 SSTTBB__LLOOPPRROOCC  This  value  up to and including SSTTBB__HHIIPPRROOCC is reserved for processor-
                             specific semantics.

                 SSTTBB__HHIIPPRROOCC  This value down to and including SSTTBB__LLOOPPRROOCC is reserved for processor-
                             specific semantics.

                             There  are  macros  for  packing  and  unpacking  the binding and type
                             fields:

                             EELLFF3322__SSTT__BBIINNDD(info) or EELLFF6644__SSTT__BBIINNDD(info) extract a binding  from  an
                             _s_t___i_n_f_o value.

                             EELLFF3322__SSTT__TTYYPPEE(info) or EELLFF6644__SSTT__TTYYPPEE(info)
                             extract a type from an _s_t___i_n_f_o value.

                             EELLFF3322__SSTT__IINNFFOO(bind, type) or EELLFF6644__SSTT__IINNFFOO(bind, type)
                             convert a binding and a type into an _s_t___i_n_f_o value.

       _s_t___o_t_h_e_r  This member defines the symbol visibility.

                 SSTTVV__DDEEFFAAUULLTT     Default symbol visibility rules.
                 SSTTVV__IINNTTEERRNNAALL    Processor-specific hidden class.
                 SSTTVV__HHIIDDDDEENN      Symbol is unavailable in other modules.
                 SSTTVV__PPRROOTTEECCTTEEDD   Not preemptible, not exported.

                 There are macros for extracting the visibility type:

                 EELLFF3322__SSTT__VVIISSIIBBIILLIITTYY(other) or EELLFF6644__SSTT__VVIISSIIBBIILLIITTYY(other)

       _s_t___s_h_n_d_x  Every  symbol  table  entry is "defined" in relation to some section.  This member
                 holds the relevant section header table index.

       Relocation is the process of  connecting  symbolic  references  with  symbolic  definitions.
       Relocatable files must have information that describes how to modify their section contents,
       thus allowing executable and shared object  files  to  hold  the  right  information  for  a
       process's program image.  Relocation entries are these data.

       Relocation structures that do not need an addend:

           typedef struct {
               Elf32_Addr r_offset;
               uint32_t   r_info;
           } Elf32_Rel;

           typedef struct {
               Elf64_Addr r_offset;
               uint64_t   r_info;
           } Elf64_Rel;

       Relocation structures that need an addend:

           typedef struct {
               Elf32_Addr r_offset;
               uint32_t   r_info;
               int32_t    r_addend;
           } Elf32_Rela;

           typedef struct {
               Elf64_Addr r_offset;
               uint64_t   r_info;
               int64_t    r_addend;
           } Elf64_Rela;

       _r___o_f_f_s_e_t    This  member  gives the location at which to apply the relocation action.  For a
                   relocatable file, the value is the byte offset from the beginning of the section
                   to  the  storage  unit  affected  by  the relocation.  For an executable file or
                   shared object, the value is the virtual address of the storage unit affected  by
                   the relocation.

       _r___i_n_f_o      This  member gives both the symbol table index with respect to which the reloca-
                   tion must be made and the type of relocation to  apply.   Relocation  types  are
                   processor-specific.   When  the  text  refers to a relocation entry's relocation
                   type or symbol table index, it means the result of applying EELLFF[[3322||6644]]__RR__TTYYPPEE or
                   EELLFF[[3322||6644]]__RR__SSYYMM, respectively, to the entry's _r___i_n_f_o member.

       _r___a_d_d_e_n_d    This  member  specifies a constant addend used to compute the value to be stored
                   into the relocatable field.

       The .dynamic section contains a series of structures  that  hold  relevant  dynamic  linking
       information.  The d_tag member controls the interpretation of d_un.

           typedef struct {
               Elf32_Sword    d_tag;
               union {
                   Elf32_Word d_val;
                   Elf32_Addr d_ptr;
               } d_un;
           } Elf32_Dyn;
           extern Elf32_Dyn _DYNAMIC[];

           typedef struct {
               Elf64_Sxword    d_tag;
               union {
                   Elf64_Xword d_val;
                   Elf64_Addr  d_ptr;
               } d_un;
           } Elf64_Dyn;
           extern Elf64_Dyn _DYNAMIC[];

       _d___t_a_g     This member may have any of the following values:

                 DDTT__NNUULLLL     Marks end of dynamic section

                 DDTT__NNEEEEDDEEDD   String table offset to name of a needed library

                 DDTT__PPLLTTRREELLSSZZ Size in bytes of PLT relocs

                 DDTT__PPLLTTGGOOTT   Address of PLT and/or GOT

                 DDTT__HHAASSHH     Address of symbol hash table

                 DDTT__SSTTRRTTAABB   Address of string table

                 DDTT__SSYYMMTTAABB   Address of symbol table

                 DDTT__RREELLAA     Address of Rela relocs table

                 DDTT__RREELLAASSZZ   Size in bytes of Rela table

                 DDTT__RREELLAAEENNTT  Size in bytes of a Rela table entry

                 DDTT__SSTTRRSSZZ    Size in bytes of string table

                 DDTT__SSYYMMEENNTT   Size in bytes of a symbol table entry

                 DDTT__IINNIITT     Address of the initialization function

                 DDTT__FFIINNII     Address of the termination function

                 DDTT__SSOONNAAMMEE   String table offset to name of shared object

                 DDTT__RRPPAATTHH    String table offset to library search path (deprecated)

                 DDTT__SSYYMMBBOOLLIICC Alert  linker  to  search this shared object before the executable for
                             symbols

                 DDTT__RREELL      Address of Rel relocs table

                 DDTT__RREELLSSZZ    Size in bytes of Rel table

                 DDTT__RREELLEENNTT   Size in bytes of a Rel table entry

                 DDTT__PPLLTTRREELL   Type of reloc the PLT refers (Rela or Rel)

                 DDTT__DDEEBBUUGG    Undefined use for debugging

                 DDTT__TTEEXXTTRREELL  Absence of this indicates no relocs should apply to a nonwritable seg-
                             ment

                 DDTT__JJMMPPRREELL   Address of reloc entries solely for the PLT

                 DDTT__BBIINNDD__NNOOWW Instruct dynamic linker to process all relocs before transferring con-
                             trol to the executable

                 DDTT__RRUUNNPPAATTHH  String table offset to library search path

                 DDTT__LLOOPPRROOCC   Start of processor-specific semantics

                 DDTT__HHIIPPRROOCC   End of processor-specific semantics

       _d___v_a_l     This member represents integer values with various interpretations.

       _d___p_t_r     This  member  represents  program  virtual  addresses.   When  interpreting  these
                 addresses,  the actual address should be computed based on the original file value
                 and memory base address.  Files do not contain relocation entries to  fixup  these
                 addresses.

       ___D_Y_N_A_M_I_C  Array  containing  all  the  dynamic  structures in the .dynamic section.  This is
                 automatically populated by the linker.

NNOOTTEESS
       ELF first appeared in System V.  The ELF format is an adopted standard.

       The extensions for _e___p_h_n_u_m, _e___s_h_n_u_m and _e___s_t_r_n_d_x respectively are  Linux  extensions.   Sun,
       BSD and AMD64 also support them; for further information, look under SEE ALSO.

SSEEEE AALLSSOO
       aass(1), ggddbb(1), lldd(1), oobbjjdduummpp(1), eexxeeccvvee(2), ccoorree(5)

       Hewlett-Packard, _E_l_f_-_6_4 _O_b_j_e_c_t _F_i_l_e _F_o_r_m_a_t.

       Santa Cruz Operation, _S_y_s_t_e_m _V _A_p_p_l_i_c_a_t_i_o_n _B_i_n_a_r_y _I_n_t_e_r_f_a_c_e.

       UNIX System Laboratories, "Object Files", _E_x_e_c_u_t_a_b_l_e _a_n_d _L_i_n_k_i_n_g _F_o_r_m_a_t _(_E_L_F_).

       Sun Microsystems, _L_i_n_k_e_r _a_n_d _L_i_b_r_a_r_i_e_s _G_u_i_d_e.

       AMD64  ABI Draft, _S_y_s_t_e_m _V _A_p_p_l_i_c_a_t_i_o_n _B_i_n_a_r_y _I_n_t_e_r_f_a_c_e _A_M_D_6_4 _A_r_c_h_i_t_e_c_t_u_r_e _P_r_o_c_e_s_s_o_r _S_u_p_p_l_e_-
       _m_e_n_t.

CCOOLLOOPPHHOONN
       This page is part of release 4.04 of the Linux _m_a_n_-_p_a_g_e_s  project.   A  description  of  the
       project, information about reporting bugs, and the latest version of this page, can be found
       at http://www.kernel.org/doc/man-pages/.

Linux                                        2013-04-17                                      ELF(5)
